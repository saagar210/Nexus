import { getDatabase } from '../connection'
import { nanoid } from 'nanoid'
import type { Collection } from '@shared/ipc-types'

interface CollectionRow {
  id: string
  workspace_id: string
  parent_id: string | null
  name: string
  description: string | null
  sort_order: number
  is_auto_generated: number
  created_at: string
}

function rowToCollection(row: CollectionRow): Collection {
  return {
    id: row.id,
    workspaceId: row.workspace_id,
    parentId: row.parent_id,
    name: row.name,
    description: row.description,
    sortOrder: row.sort_order,
    isAutoGenerated: Boolean(row.is_auto_generated),
    createdAt: row.created_at,
  }
}

export function listCollections(workspaceId: string): Collection[] {
  const db = getDatabase()
  const rows = db.prepare(
    'SELECT * FROM collections WHERE workspace_id = ? ORDER BY sort_order, name'
  ).all(workspaceId) as CollectionRow[]
  return rows.map(rowToCollection)
}

export function getCollection(id: string): Collection | null {
  const db = getDatabase()
  const row = db.prepare('SELECT * FROM collections WHERE id = ?').get(id) as CollectionRow | undefined
  return row ? rowToCollection(row) : null
}

export function createCollection(args: {
  workspaceId: string
  parentId?: string | null
  name: string
  description?: string | null
}): Collection {
  const db = getDatabase()
  const id = nanoid()

  db.prepare(`
    INSERT INTO collections (id, workspace_id, parent_id, name, description)
    VALUES (?, ?, ?, ?, ?)
  `).run(id, args.workspaceId, args.parentId ?? null, args.name, args.description ?? null)

  const row = db.prepare('SELECT * FROM collections WHERE id = ?').get(id) as CollectionRow
  return rowToCollection(row)
}

export function updateCollection(id: string, updates: {
  name?: string
  parentId?: string | null
  sortOrder?: number
  description?: string | null
}): Collection {
  const db = getDatabase()

  const fields: string[] = []
  const values: unknown[] = []

  if (updates.name !== undefined) { fields.push('name = ?'); values.push(updates.name) }
  if (updates.parentId !== undefined) { fields.push('parent_id = ?'); values.push(updates.parentId) }
  if (updates.sortOrder !== undefined) { fields.push('sort_order = ?'); values.push(updates.sortOrder) }
  if (updates.description !== undefined) { fields.push('description = ?'); values.push(updates.description) }

  if (fields.length > 0) {
    values.push(id)
    db.prepare(`UPDATE collections SET ${fields.join(', ')} WHERE id = ?`).run(...values)
  }

  const row = db.prepare('SELECT * FROM collections WHERE id = ?').get(id) as CollectionRow
  return rowToCollection(row)
}

export function deleteCollection(id: string): void {
  const db = getDatabase()
  db.prepare('DELETE FROM collections WHERE id = ?').run(id)
}

export function reorderCollections(items: Array<{ id: string; sortOrder: number; parentId?: string | null }>): void {
  const db = getDatabase()
  const stmt = db.prepare('UPDATE collections SET sort_order = ?, parent_id = ? WHERE id = ?')

  const transaction = db.transaction(() => {
    for (const item of items) {
      stmt.run(item.sortOrder, item.parentId ?? null, item.id)
    }
  })

  transaction()
}
